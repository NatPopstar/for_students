<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Машины Тьюринга</title>
    <link rel="stylesheet" href="chapters.css">
</head>
<body>
    <main>
        <h1>Тема 5.1. Понятие алгоритма. Машины Тьюринга</h1>
        <h3><i>Развитие теории алгоритмов</i></h3>
        <p>Теория алгоритмов — наука, находящаяся на стыке математики и информатики, изучающая общие свойства и закономерности алгоритмов и разнообразные формальные модели их представления. Вместе с математической логикой теория алгоритмов образует теоретическую основу вычислительных наук.</p>
        <p>Развитие теории алгоритмов начинается с доказательства Куртом Гёделем теорем о неполноте формальных систем, включающих арифметику, первая из которых была доказана в 1931 году. Возникшее в связи с этими теоремами предположение о невозможности алгоритмического разрешения многих математических проблем (в частности, проблемы выводимости в исчислении предикатов) вызвало необходимость стандартизации понятия алгоритма. Первые стандартизованные варианты этого понятия были разработаны в 1930-е годы в работах Алана Тьюринга, Эмиля Поста и Алонзо Чёрча. Предложенные ими машина Тьюринга, машина Поста и лямбда-исчисление оказались эквивалентными друг другу. Основываясь на работах Гёделя, Стивен Клини ввёл понятие рекурсивной функции, также оказавшееся эквивалентным вышеперечисленным.</p>
        <p>В 1950-е годы существенный вклад в теорию алгоритмов внесли работы Колмогорова и Маркова.</p>
        <p>Во второй половине ХХ века оформились следующие направления в теории алгоритмов:</p>
        <ul>
            <li><b>Классическая теория алгоритмов </b> (формулировка задач в терминах формальных языков, понятие задачи разрешения, введение сложностных классов, формулировка в 1965 году Эдмондсом проблемы P=NP, открытие класса NP-полных задач и его исследование);</li>
            <li><b>Теория асимптотического анализа алгоритмов </b> (критерии оценки алгоритмов, методы получения асимптотических оценок, в частности для рекурсивных алгоритмов, асимптотический анализ трудоемкости или времени выполнения), в развитие которой внесли существенный вклад Кнут, Ахо, Хопкрофт;</li>
            <li><b>Теория практического анализа вычислительных алгоритмов </b> (получение явных функции трудоёмкости, интервальный анализ функций, практические критерии качества алгоритмов, методика выбора рациональных алгоритмов), основополагающей работой в этом направлении, очевидно, следует считать фундаментальный труд Д. Кнута «Искусство программирования для ЭВМ» </li>        </ul>
        <h3><i>Основные определения </i></h3>
        <p><b>Алгоритм</b> - это заданное на некотором языке конечное предписание, задающее конечную последовательность выполнимых элементарных операций для решения задачи, общее для класса возможных исходных данных.</p>
        <p><b>Алгоритм</b> (Колмогоров) – это всякая система вычислений, выполняемых по строго определенным правилам, которая после какого-либо числа шагов заведомо приводит к решению поставленной задачи.</p>
        <p><b>Алгоритм</b> (Марков) – это точное предписание, определяющее вычислительный процесс, идущий от варьируемых исходных данных к искомому результату.</p>
        <p>Различные рассмотренные определения алгоритма, объединяет то, что во всех этих определениях присутствует в явном или неявном виде следующий ряд требований:</p>
        <ul>
            <li>алгоритм должен содержать конечное количество элементарно выполнимых предписаний, т.е. удовлетворять требованию конечности записи;</li>
            <li>алгоритм должен выполнять конечное количество шагов при решении задачи, т.е. удовлетворять требованию конечности действий;</li>
            <li>алгоритм должен быть единым для всех допустимых исходных данных, т.е. удовлетворять требованию универсальности;</li>
            <li>алгоритм должен приводить к правильному по отношению к поставленной задаче решению, т.е. удовлетворять требованию правильности.</li>
        </ul>
        <p>Другие формальные определения понятия алгоритма связаны с введением специальных математических конструкций (машина Тьюринга, рекурсивно-вычислимые функции Черча) и постулированием тезиса об эквивалентности такого формализма и понятия «алгоритм».</p>
        <h3><i>Машина Тьюринга</i></h3>
        <p>Введение понятия машины Тьюринга явилось одной из первых и весьма удачных попыток дать точный математический эквивалент для общего интуитивного представления об алгоритме. Это понятие названо по имени английского математика, сформулировавшего его в 1937 г., за 9 лет до появления первой электронно-вычислительной машины.</p>
        <p>Машина Тьюринга есть математическая (воображаемая) машина, а не машина физическая. Она состоит из: </p>
        <ol>
            <li>бесконечной в обе стороны ленты, разбитой на ячейки. В каждой ячейке записан один из символов алфавита:  . В алфавите всегда существует пустой символ (или пробел), обычно это   (считается, что этим символом лента заполнена в обе стороны до бесконечности, даже если эти символы не написаны). </li>
            <li>набора   - внутренних состояний машины. Какое-то из внутренних состояний конечное (обычно это  ), какое-то – начальное (чаще всего  ). Для каждой задачи берётся свой набор внутренних состояний, но начальное и конечное состояния существуют всегда. Эти состояния могут и совпасть.</li>
            <li>управляющей головки, двигающейся в обе стороны вдоль ленты в дискретные моменты времени. Головка читает символы алфавита, анализирует их, записывает новые символы и двигается по ленте по программе. В зависимости от внутреннего состояния в данный момент и от символа на воспринимаемой ячейке, в следующий момент машина переходит в новое состояние, записывает в ячейку новый символ. Попав в конечное состояние, машина прекращает работу.</li>
        </ol>
        <p>Конфигурация на ленте состоит из: </p>
        <ol>
            <li>последовательности символов алфавита на ленте. </li>
            <li>текущего внутреннего состояния машины. </li>
            <li>номера воспринимаемой ячейки (позиции ячейки)</li>
        </ol>
        <p>Если, в данный момент машина находится во внутреннем состоянии \(q_1\) и читается ячейка \(a_j\), в следующий момент машина переходит в состояние \(q_k\), а символ на ленте заменяется на \(a_m\), то такая <b><i>команда</i></b> записывается следующим образом: \(q_ia_j\rightarrow q_ka_mS\) , где S={L, R, C} (влево, вправо, стоп), команда стоп часто опускается. При этом машина одну конфигурацию переводит в другую.</p>
        <p><b>Программа</b> – это совокупность всех команд, выполняемых машиной. Часто записывается в виде двумерной таблицы.</p>
        <p><b>Пример:</b> Дана машина Тьюринга с внешним алфавитом  \(A=\{0,1\}\)  (здесь 0 — символ пустой ячейки), алфавитом внутренних состояний  \(Q=\{q_0,q_1,q_2\}\) и со следующей программой:</p>
        <table>
            <tr>
                <td></td>
                <td>\(q_1\)</td>
                <td>\(q_2\)</td>
            </tr>
            <tr>
                <td>0</td>
                <td>\(q_20P\)</td>
                <td>\(q_01\)</td>
            </tr>
            <tr>
                <td>1</td>
                <td>\(q_1 1P\)</td>
                <td>\(q_2 1P\)</td>
            </tr>
        </table>
        <p>Посмотрим, в какое слово переработает эта машина слово 101, если изначально машина находится в состоянии
            \(q_1\) и просматривается крайняя правая ячейка.</p>
        <p>Будем последовательно выписывать конфигурации машины при переработке ею этого слова. Изначально:</p>
        <table class="machine">
            <tr>
                <td></td><td></td><td></td><td>\(q_1\)</td><td></td><td></td><td></td><td></td><td></td>
            </tr>
            <tr>
                <td></td><td>1</td><td>0</td><td>1</td><td></td><td></td><td></td><td></td><td></td>
            </tr>
        </table>
        <p>На первом шаге по таблице находим, что должна примениться команда \(q_1 1\rightarrow q_1 1P\), т.е. мы
            последовательно делаем следующее: заменяем символ на 1 (у нас не меняется), заменяем состояние машины
            на \(q_1\) (опять не меняется) и сдвигаемся по ленте вправо. В результате получим следующую конфигурацию
            (с учетом того, что пустая ячейка у нас содержит 0):</p>
        <table class="machine">
            <tr>
                <td></td><td></td><td></td><td></td><td>\(q_1\)</td><td></td><td></td><td></td><td></td>
            </tr>
            <tr>
                <td></td><td>1</td><td>0</td><td>1</td><td>0</td><td></td><td></td><td></td><td></td>
            </tr>
        </table>
        <p>Теперь будет действовать команда: \(q_1 0\rightarrow q_2 0P\) (0 заменяем на 0, состояние \(q_1\) - на состояние
            \(q_2\) и сдвигаемся вправо) и на машине создается конфигурация:</p>
        <table class="machine">
            <tr>
                <td></td><td></td><td></td><td></td><td></td><td>\(q_1\)</td><td></td><td></td><td></td>
            </tr>
            <tr>
                <td></td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td></td><td></td><td></td>
            </tr>
        </table>
        <p>На третьем шаге получим по таблице команду: \(q_2 0\rightarrow q_0 1\) . В результате чего создается
            конфигурация:</p>
        <table class="machine">
            <tr>
                <td></td><td></td><td></td><td></td><td></td><td>\(q_1\)</td><td></td><td></td><td></td>
            </tr>
            <tr>
                <td></td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td></td><td></td><td></td>
            </tr>
        </table>
        <p>Эта конфигурация является заключительной, потому что машина оказалась в состоянии остановки \(q_0\).</p>
        <p>Таким образом, исходное слово 101 переработано машиной в слово 10101.</p>
        <p>Создание (синтез) машин Тьюринга (т.е. написание соответствующих программ) является задачей значительно
            более сложной, нежели процесс применения данной машины к данным словам и обычно рассматривается в предмете
            «Математическая логика и теория алгоритмов».</p>
        <p><b>Тезис Тьюринга (основная гипотеза теории алгоритмов)</b>: Для нахождения значений функции, заданной в некотором алфавите, тогда и только тогда существует какой-нибудь алгоритм, когда функция является вычислимой по Тьюрингу, т.е. когда она может вычисляться на подходящей машине Тьюринга.</p>
        <p>Это означает, что строго математическое понятие вычислимой (по Тьюрингу) функции является по существу идеальной моделью взятого из опыта понятия алгоритма. Данный тезис есть не что иное, как аксиома, постулат, выдвигаемый нами, о взаимосвязях нашего опыта с той математической теорией, которую мы под этот опыт хотим подвести. Конечно же данный тезис в принципе не может быть доказан методами математики, потому что он не имеет внутриматематического характера (одна сторона в тезисе — понятие алгоритма — не является точным математическим понятием). Он выдвинут исходя из опыта, и именно опыт подтверждает его состоятельность. Точно так же, например, не могут быть доказаны и математические законы механики; они открыты Ньютоном и многократно подтверждены опытом.</p>
        <p>Впрочем, не исключается принципиальная возможность того, что тезис Тьюринга будет опровергнут. Для этого должна быть указана функция, которая вычислима с помощью какого-нибудь алгоритма, но невычислима ни на какой машине Тьюринга. Но такая возможность представляется маловероятной (в этом одно из значений гипотезы): всякий алгоритм, который будет открыт, может быть реализован на машине Тьюринга.</p>
    </main>

    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>