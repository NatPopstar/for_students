<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Алгоритмы Маркова</title>
</head>
<body>
    <main>
        <h1><i>Тема 5.2. Рекурсивные функции. Нормальные алгоритмы Маркова</i></h1>
        <h3><i>Рекурсивные функции</i></h3>
        <p>Рассмотрим очень коротко еще одну модель уточнения понятия алгоритма – рекурсивные функции.</p>
        <p>Всякий алгоритм однозначно сопоставляет допустимым начальным данным результат. Это означает, что с каждым алгоритмом однозначно связана функция, которую он вычисляет. Отсюда возникает вопрос: для всякой ли функции можно указать вычисляющую ее машину Тьюринга, а если нет, то для каких функций существует вычисляющий их алгоритм (машина Тьюринга), как описать такие, как говорят, алгоритмически или эффективно вычислимые функции?</p>
        <p>Исследование этих вопросов привело к созданию в 1930-х гг. теории рекурсивных функций. При этом класс вычислимых функций (названных здесь рекурсивными) получил такое описание, которое весьма напомнило процесс построения аксиоматической теории на базе некоторой системы аксиом. Сначала были выбраны простейшие функции, эффективная вычислимость которых была очевидна (своего рода «аксиомы»). Затем сформулированы некоторые правила (названные операторами), на основе которых можно строить новые функции из уже имеющихся.</p>
        <p>В качестве исходных простейших функций выберем следующие:</p>
        <p>\(S\left ( x \right )= x+1\) (функция следования);</p>
        <p>\(O\left ( x \right )= 0\) (нуль-функция);</p>
        <p>\(I_m^n(x_1, x_2, ..., x_n) = x_m\) (функции-проекторы,  , т.е. функции, результатом которой является один,
            вполне определенный ее аргумент).</p>
        <p>Будем говорить, что \(n\)-местная функция \(\varphi\) получена из \(m\)-местной функции \(f\) и \(n\)-местных функций
            \(g_1, g_2, ..., g_m\) с помощью <b>оператора суперпозиции</b>, если для всех \(x_1, x_2,...,x_n\) справедливо
            равенство:</p>
        <p>\(\varphi(x_1,x_2,...,x_n)=f(g_1(x_1,x_2,...,x_n),...,g_m(x_1,x_2,...,x_n))\)</p>
        <p>Теорема: <i>Если функции \(f(x_1, x_2,...,x_m), g_1(x_1,x_2,...,x_n),...,g_m(x_1,x_2,...,x_n)\) правильно
            вычислимы по Тьюрингу, то правильно вычислима и сложная функция (суперпозиция функций):
            \(\varphi(x_1,x_2,...,x_n)=f(g_1(x_1,x_2,...,x_n),...,g_m(x_1,x_2,...,x_n))\)
        </i></p>
        <p>Примем эту теорему без доказательства.</p>
        <p>Говорят, что  \((n+1)\)-местная функция \(\varphi\) получена из \(n\)-местной функции \(f\) и \((n+2)\)-местной функции
            \(g\) с помощью <b><i>оператора примитивной рекурсии</i></b>, если для любых \(x_1,x_2,...,x_n,y\), справедливы
            равенства:</p>
        <p>\(\varphi(x_1,x_2,...,x_n,0)=f(x_1,x_2,...,x_n)\),</p>
        <p>\(\varphi(x_1,x_2,...,x_n,y+1)=g(x_1,x_2,...,x_n,y,\varphi(x_1,x_2,...x_n,y))\)</p>
        <p>Пара этих равенств называется <b><i>схемой примитивной рекурсии.</i></b></p>
        <p>Функция называется <b><i>примитивно рекурсивной</i></b>, если она может быть получена из простейших функций
            О, S, \(I_m^n\) с помощью конечного числа применений операторов суперпозиции и примитивной рекурсии.</p>
        <p>Наконец, введем заключительный, третий, оператор.</p>
        <p>Определение 33.5 (оператор минимизации). Будем говорить, что \(n\)-местная функция \(\varphi\) получается из
            \((n+1)\)-местных функций \(f_1\) и \(f_2\) с помощью <b><i>оператора минимизации</i></b>, или <b><i>оператора
                наименьшего числа</i></b>, если для любых \(x_1,x_2,...,x_n,y\) равенство \(\varphi(x_1,x_2,...,x_n)=y\)
            выполнено тогда и только тогда, когда величина \(\varphi(x_1,x_2,...,x_n)\) равна наименьшему значению
            аргумента у, при котором выполняется это равенство.</p>
        <p>Функция называется <b><i>частично рекурсивной</i></b>, если она может быть получена из простейших функций
            О, S, \(I_m^n\) с помощью конечного числа применений суперпозиции, примитивной рекурсии и оператора
            минимизации. Если функция всюду определена и частично рекурсивна, то она называется
            <b><i>общерекурсивной</i></b>.
        </p>
        <p>Подобно тезису Тьюринга, в теории рекурсивных функций выдвигается соответствующая гипотеза, носящая название
            тезиса Чёрча:
        </p>
        <p><i>Числовая функция тогда и только тогда алгоритмически (или машинно) вычислима, когда она частично
            рекурсивна.</i></p>
        <p>
            И эта гипотеза не может быть доказана строго математически, она подтверждается практикой, опытом, ибо
            призвана увязать практику и теорию. Все рассматривавшиеся в математике конкретные функции, признаваемые
            вычислимыми в интуитивном смысле, оказывались частично рекурсивными.
            </p>
        <p>Рекурсивные функции также рассматриваются подробно в предмете «Математическая логика и теория алгоритмов».</p>

        <h3><i>Нормальные алгоритмы Маркова</i></h3>
        <p>Также очень коротко рассмотрим еще одну модель, называемую нормальными алгоритмами Маркова -  один из
            стандартных способов формального определения понятия алгоритма. Понятие нормального алгоритма введено
            А. А. Марковым (младшим) в конце 1940-х годов в работах по неразрешимости некоторых проблем теории
            ассоциативных вычислений.
        </p>
        <p>Нормальный алгоритм описывает метод переписывания строк, похожий по способу задания на формальные
            грамматики. НАМ — полный по Тьюрингу язык, что делает его по выразительной силе эквивалентным машине
            Тьюринга и, следовательно, современным языкам программирования. На основе НАМ был создан функциональный
            язык программирования Рефал.
            </p>
        <p><b><i>Алфавитом</i></b> называется любое непустое множество. Его элементы называются <b><i>буквами</i></b>,
            а любые последовательности букв — <b><i>словами</i></b> в данном алфавите. Для удобства рассуждений
            допускаются пустые слова. Пустое слово будем обозначать \(A\). Если А и В — два алфавита, причем
            \(A\subseteq B\), то алфавит В называется <b><i>расширением</i></b> алфавита А.
        </p>
        <p>Слова будем обозначать латинскими буквами: P, Q, R. Одно слово может быть составной частью другого слова.
            Тогда первое называется <b><i>подсловом</i></b> второго или вхождением во второе.
        </p>
        <p><b><i>Марковской подстановкой</i></b> называется операция над словами, задаваемая с помощью упорядоченной
            пары слов \((P,Q)\), состоящая в следующем. В заданном слове R находят первое вхождение слова P (если
            таковое имеется) и, не изменяя остальных частей слова R, заменяют в нем это вхождение словом Q. Полученное
            слово называется результатом применения марковской подстановки \((P,Q)\) к слову R. Если же первого вхождения \
            P в слово R нет, то считается, что марковская подстановка \((P,Q)\) неприменима к слову R.
        </p>
        <p>Для обозначения марковской подстановки \((P,Q)\) используется запись \(P\rightarrow Q\). Она называется формулой
            подстановки \((P, Q)\). Для заключительной подстановки будем использовать обозначение \(P\rightarrow Q\)</p>
        <p>Упорядоченный конечный список формул подстановок \(\left\{\begin{matrix} P_1\rightarrow (.)Q_1\\ P_2\rightarrow (.)Q_2\\ ...\\ P_n\rightarrow (.)Q_n\end{matrix}\right.\)
            в алфавите A называется схемой (или записью) нормального алгоритма в A. (Запись точки в скобках означает,
            что она может стоять в этом месте, а может отсутствовать.) Данная схема определяет (детерминирует)
            алгоритм преобразования слов, называемый нормальным алгоритмом Маркова. Дадим его точное определение.
        </p>
        <p>Нормальным алгоритмом (Маркова) в алфавите A называется следующее правило построения последовательности \(V_i\)
            слов в алфавите A, исходя из данного слова V в этом алфавите. В качестве начального слова \(V_0\)
            последовательности берется слово V. Пусть для некоторого \(i\geq 0\) слово \(V_i\) построено и процесс
            построения рассматриваемой последовательности еще не завершился. Если при этом в схеме нормального
            алгоритма нет формул, левые части которых входили бы в \(V_i\), то \(V_{i+1\) полагают равным \(V\), и процесс
            построения последовательности считается завершившимся. Если же в схеме имеются формулы с левыми частями,
            входящими в \(V_i\), то в качестве \(V_{i+1}\) берется результат марковской подстановки правой части первой из
            таких формул вместо первого вхождения ее левой части в слово \(V_i\); процесс построения последовательности
            считается завершившимся, если на данном шаге была применена формула заключительной подстановки) и
            продолжающимся — в противном случае. Если процесс построения упомянутой последовательности обрывается,
            то говорят, что рассматриваемый нормальный алгоритм применим к слову V. Последний член W последовательности
            называется результатом применения нормального алгоритма к слову V. </p>
        <p><b>Пример:</b> Пусть \(A=\{a,b\}\) - алфавит. Рассмотрим следующую схему нормального алгоритма в А:
            \(\left\{\begin{matrix}a\rightarrow.\Lambda \\ b\rightarrow b. \end{matrix}\right.\)</p>
        <p>Тогда получим, например, следующие соотношения:</p>
        <p>\(aaba\Rightarrow aba\),</p>
        <p>\(aaaa\Rightarrow aaa\),</p>
        <p>\(bbaaba\Rightarrow bbaba\),</p>
        <p>\(bbba\Rightarrow bbb\),</p>
        <p>\(bababab\Rightarrow bbabab\)</p>
        <p>Т.е. всякое слово в алфавите A, содержащее хотя бы одно вхождение буквы a, он перерабатывает в слово,
            получающееся вычеркиванием в нем самого левого (первого) вхождения буквы а. Пустое слово он перерабатывает
            в пустое. (Алгоритм не применим к таким словам, которые содержат только букву b.)</p>
        <p>Как и машины Тьюринга, нормальные алгоритмы не производят собственно вычислений: они лишь производят
            преобразования слов, заменяя в них одни буквы другими по предписанным им правилам. В свою очередь, мы
            предписываем им такие правила, результаты применения которых мы можем интерпретировать как вычисления.</p>
        <p>Функция \(f\), заданная на некотором множестве слов алфавита A, называется <b><i>нормально</i></b> вычислимой,
            если найдется такое расширение B данного алфавита ( \(A\subseteq B\) ) и такой нормальный алгоритм в \(B\),
            что каждое слово \(V\) (в алфавите \(A\)) из области определения функции \(f\) этот алгоритм перерабатывает
            в слово \(f(V)\)</p>
        <p>Создатель теории нормальных алгоритмов советский математик А. А. Марков выдвинул гипотезу, получившую
            название «<b>Принцип нормализации Маркова</b>». Согласно этому принципу, <i>для нахождения значений функции,
            заданной в некотором алфавите, тогда и только тогда существует какой-нибудь алгоритм, когда функция
            нормально вычислима.</i></p>

    </main>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>